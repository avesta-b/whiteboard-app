What risks have you identified in your requirements? Do you have strategies to mitigate those risks?

- Syncing components on the whiteboard
    We are planning to use Websockets to implement automatic sync between clients. However, in order to reduce latency to the end user, edits made by the user locally must be shown in real-time, before we broadcast it to the Websocket connection. This brings about a synchronization issue, for instance when two clients edit the same component on the whiteboard. To mitigate this risk, we plan to use the Websocket server as a single source of truth. The server will contain logic to resolve edit conflicts (for example using a last-write-wins strategy) and it will be the one to have the final say in determining which user edit is kept, and each of the clients will always accept all changes broadcasted by the server.

- WebSocket data transfer performance
    Another issue that will come up with automatic sync between clients is that we have to be careful about the size of the data we send through the socket. For example, a user that moves a component across the whiteboard will have to be able to communicate the position of the component in small time-intervals in order to order for the move to be observed “in real-time” by other clients. As a consequence of these frequent sends, encoding the entire component object would be extremely expensive. To mitigate this risk, we plan to structure our whiteboard using a two-level map: Map<ComponentID, Map<Property, Value>>. We wil also comeup with our own schema for transferring data related to user edits. Everytime a user makes a change, we only need to send the component id, the property changed, and the value as opposed to the entire object.

- Client-side performance when editing
    Finally, an expensive editing operation on client side is selecting components on the whiteboard. In order for a good user experience, this operation should be nearly instantaneous, but if we use a naive approach to searching for components in the selected area, it does not scale well for when we have a large number of components on the whiteboard. We can use an alternate data structure on client-side called kd-trees to store the coordinates of components and their size, reducing our range search to $O(\sqrt{n})$ time where $n$ is the number of components.
